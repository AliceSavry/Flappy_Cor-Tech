<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Cor-Tech</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Fredoka+One&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            touch-action: none;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 480px;
            aspect-ratio: 9/16;
            background-color: #4FC3F7; /* Bleu Ciel */
            overflow: hidden;
            border-radius: 4px;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .message {
            color: white;
            text-shadow: 4px 4px 0 #000;
            display: none;
            pointer-events: auto;
            width: 85%;
            z-index: 20;
            flex-direction: column;
            align-items: center;
        }

        /* Titre Dopaminé */
        h1 {
            font-family: 'Fredoka One', cursive;
            font-size: 3rem;
            margin-bottom: 20px;
            color: #FFEB3B;
            -webkit-text-stroke: 2px #000;
            text-shadow: 5px 5px 0 #e65100;
            animation: bounceTitle 2s infinite ease-in-out;
            line-height: 1.1;
        }

        @keyframes bounceTitle {
            0%, 100% { transform: scale(1) rotate(-3deg); }
            50% { transform: scale(1.1) rotate(3deg); }
        }

        #score-display {
            position: absolute;
            top: 10%;
            width: 100%;
            text-align: center;
            font-family: 'Fredoka One', cursive;
            font-size: 4rem;
            color: white;
            -webkit-text-stroke: 2px #000;
            text-shadow: 4px 4px 0 rgba(0,0,0,0.3);
            z-index: 10;
            pointer-events: none;
            transition: transform 0.1s;
        }

        .score-pop {
            transform: scale(1.5);
            color: #FFEB3B !important;
        }

        /* Indicateur Mode Démo */
        #demo-indicator {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            text-shadow: 2px 2px 0 #000;
            animation: pulse 1s infinite;
            display: none;
            z-index: 30;
            pointer-events: none;
        }

        /* --- MENUS & BOUTONS --- */
        
        .menu-btn {
            font-family: 'Press Start 2P', cursive;
            background: #FFEB3B; /* Jaune */
            color: #000;
            border: 4px solid #000;
            padding: 15px 20px;
            font-size: 0.8rem;
            cursor: pointer;
            margin-top: 15px;
            border-radius: 10px;
            box-shadow: 0 6px 0 #F57F17;
            transition: all 0.1s;
            text-transform: uppercase;
            width: 100%;
            max-width: 250px;
        }

        .menu-btn:active {
            box-shadow: 0 2px 0 #F57F17;
            transform: translateY(4px);
        }

        .menu-btn.primary {
            background: #00E676; /* Vert */
            box-shadow: 0 6px 0 #00aa55;
        }
        .menu-btn.primary:active { box-shadow: 0 2px 0 #00aa55; }

        .menu-btn.secondary {
            background: #FFF;
            box-shadow: 0 6px 0 #ccc;
        }
        .menu-btn.secondary:active { box-shadow: 0 2px 0 #ccc; }

        /* Leaderboard Modal */
        #leaderboard-screen {
            background: rgba(0,0,0,0.85);
            padding: 20px;
            border-radius: 15px;
            border: 4px solid #fff;
            backdrop-filter: blur(5px);
        }

        .leaderboard-box {
            width: 100%;
            margin-bottom: 20px;
        }

        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin: 12px 0;
            color: #fff;
            border-bottom: 2px dotted #555;
            padding-bottom: 5px;
            font-family: 'Press Start 2P', cursive;
        }
        
        .leaderboard-row:first-child { color: #FFEB3B; font-weight: bold; }

        /* Input */
        #new-record-section { display: none; margin-bottom: 15px; width: 100%; }
        input[type="text"] {
            font-family: 'Press Start 2P', cursive;
            background: #fff;
            border: 4px solid #000;
            color: #000;
            padding: 10px;
            width: 80%;
            text-transform: uppercase;
            font-size: 0.8rem;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 10px;
        }
        
        .blink { animation: blinker 0.8s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

    </style>
</head>
<body>

    <div id="game-container">
        <div id="score-display">0</div>
        <canvas id="gameCanvas"></canvas>
        <div id="demo-indicator">MODE DÉMO<br>TOUCHER POUR JOUER</div>
        
        <div id="ui-layer">
            <!-- ECRAN ACCUEIL -->
            <div id="start-screen" class="message" style="display: flex;">
                <h1>FLAPPY<br>COR-TECH</h1>
                <p class="blink" style="font-size:0.7rem; color:#fff; text-shadow:2px 2px 0 #000; margin-bottom: 30px;">
                    APPUYER POUR DÉCOLLER
                </p>
                <button id="btn-show-scores" class="menu-btn">🏆 CLASSEMENT</button>
            </div>
            
            <!-- ECRAN CLASSEMENT (Masqué par défaut) -->
            <div id="leaderboard-screen" class="message">
                <h2 style="color:#FFEB3B; margin-bottom:20px; font-family:'Fredoka One'; font-size: 2rem; -webkit-text-stroke: 1px #000;">TOP PILOTES</h2>
                <div class="leaderboard-box">
                    <div id="leaderboard-list">Chargement...</div>
                </div>
                <button id="btn-back-home" class="menu-btn secondary">⬅ RETOUR</button>
            </div>
            
            <!-- ECRAN GAME OVER -->
            <div id="game-over-screen" class="message">
                <h1 style="color: #FF5252; font-size: 2.5rem;">BOOM !</h1>
                <div style="font-size: 1.2rem; margin-bottom: 15px; font-family:'Fredoka One';">Score: <span id="final-score" style="color:#FFEB3B">0</span></div>
                
                <div id="new-record-section">
                    <p style="color: #00E676; font-size:0.8rem; margin-bottom:10px;">NOUVEAU RECORD !</p>
                    <input type="text" id="player-name" placeholder="TON NOM" maxlength="6">
                    <button id="btn-save" class="menu-btn primary">SAUVEGARDER</button>
                </div>

                <div id="replay-prompt" style="margin-top:10px; width: 100%;">
                    <button id="btn-replay" class="menu-btn primary">REJOUER</button>
                    <button id="btn-home-from-over" class="menu-btn secondary" style="margin-top:10px;">MENU</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // UI Refs
        const scoreEl = document.getElementById('score-display');
        const startScreen = document.getElementById('start-screen');
        const leaderboardScreen = document.getElementById('leaderboard-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const demoIndicator = document.getElementById('demo-indicator');
        
        const finalScoreEl = document.getElementById('final-score');
        const leaderboardList = document.getElementById('leaderboard-list');
        const newRecordSection = document.getElementById('new-record-section');
        const playerNameInput = document.getElementById('player-name');
        
        // Boutons
        const btnShowScores = document.getElementById('btn-show-scores');
        const btnBackHome = document.getElementById('btn-back-home');
        const btnSave = document.getElementById('btn-save');
        const btnReplay = document.getElementById('btn-replay');
        const btnHomeFromOver = document.getElementById('btn-home-from-over');
        
        // --- Navigation Menus ---
        const resetInactivity = () => {
            lastActivityTime = Date.now();
            if (gameState === 'DEMO') {
                stopDemoMode();
            }
        };

        btnShowScores.addEventListener('click', (e) => {
            e.stopPropagation(); // Empêche le jeu de démarrer
            resetInactivity();
            startScreen.style.display = 'none';
            leaderboardScreen.style.display = 'flex';
        });

        btnBackHome.addEventListener('click', (e) => {
            e.stopPropagation();
            resetInactivity();
            leaderboardScreen.style.display = 'none';
            startScreen.style.display = 'flex';
        });

        btnHomeFromOver.addEventListener('click', (e) => {
            e.stopPropagation();
            resetInactivity();
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'flex';
            resetGameEnv(); 
        });

        const GAME_WIDTH = 320;
        const GAME_HEIGHT = 480;

        let frames = 0;
        let score = 0;
        let gameState = 'START'; // START, PLAYING, GAMEOVER, DEMO
        let gameSpeed = 2.5;
        let isHighscoreInputActive = false;
        
        let shakeAmount = 0;
        let flashOpacity = 0;
        let particles = [];

        // --- GESTION INACTIVITÉ (Screensaver) ---
        let lastActivityTime = Date.now();
        const INACTIVITY_LIMIT = 5 * 60 * 1000; // 5 minutes en ms

        function checkInactivity() {
            if (gameState === 'DEMO') return; // Déjà en mode démo

            if (Date.now() - lastActivityTime > INACTIVITY_LIMIT) {
                startDemoMode();
            }
        }
        
        // On vérifie l'inactivité toutes les secondes
        setInterval(checkInactivity, 1000);

        function startDemoMode() {
            gameState = 'DEMO';
            // Masquer les UI
            startScreen.style.display = 'none';
            leaderboardScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            scoreEl.style.display = 'none';
            
            // Afficher l'indicateur
            demoIndicator.style.display = 'block';
            
            // Reset jeu pour le bot
            resetGameEnv();
            gameState = 'DEMO'; // Forcer à nouveau car resetGameEnv met START
            player.jump(); // Premier saut
        }

        function stopDemoMode() {
            gameState = 'START';
            resetGameEnv(); // Reset propre
            demoIndicator.style.display = 'none';
            startScreen.style.display = 'flex';
        }

        let highScores = JSON.parse(localStorage.getItem('cortechScores')) || [
            {name: "PRO", score: 20},
            {name: "DUCK", score: 10},
            {name: "COR", score: 5},
            {name: "TECH", score: 3},
            {name: "NOOB", score: 1}
        ];

        function updateLeaderboardDisplay() {
            leaderboardList.innerHTML = "";
            highScores.sort((a, b) => b.score - a.score);
            highScores.slice(0, 5).forEach((entry, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-row';
                let medal = index === 0 ? '👑' : (index === 1 ? '🥈' : (index === 2 ? '🥉' : ''));
                div.innerHTML = `<span>${index + 1}. ${entry.name} ${medal}</span><span>${entry.score}</span>`;
                leaderboardList.appendChild(div);
            });
        }

        // --- Audio ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        function initAudio() { if (!audioCtx) audioCtx = new AudioContext(); if (audioCtx.state === 'suspended') audioCtx.resume(); }

        const music = {
            isPlaying: false, scheduler: null, nextNoteTime: 0, noteIndex: 0, tempo: 0.12,
            sequence: [
                {f: 523.25, d: 1}, {f: 659.25, d: 1}, {f: 783.99, d: 1}, {f: 1046.50, d: 1},
                {f: 783.99, d: 1}, {f: 1046.50, d: 2}, {f: 0, d: 1},
                {f: 587.33, d: 1}, {f: 739.99, d: 1}, {f: 880.00, d: 1}, {f: 1174.66, d: 1},
                {f: 880.00, d: 1}, {f: 1174.66, d: 2}, {f: 0, d: 1}
            ],
            start: function() {
                if (this.isPlaying || !audioCtx) return;
                this.isPlaying = true; this.noteIndex = 0; this.nextNoteTime = audioCtx.currentTime; this.schedule();
            },
            stop: function() { this.isPlaying = false; if (this.scheduler) clearTimeout(this.scheduler); },
            
            // --- NOUVEAU : Fonction Musique "Looser" ---
            playLoser: function() {
                this.stop(); // Arrête la musique principale
                if (!audioCtx) return;
                
                const now = audioCtx.currentTime;
                
                // Mélodie : G -> F# -> F -> E (Descente triste)
                const sadNotes = [
                    {f: 392.00, t: 0, d: 0.3},    // Sol
                    {f: 369.99, t: 0.3, d: 0.3},  // Fa#
                    {f: 349.23, t: 0.6, d: 0.3},  // Fa
                    {f: 329.63, t: 0.9, d: 0.8}   // Mi (Long)
                ];

                sadNotes.forEach(note => {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    
                    osc.type = 'sawtooth'; // Son "nasillard" triste
                    osc.frequency.setValueAtTime(note.f, now + note.t);
                    
                    // Pitch bend vers le bas (effet "pleurs")
                    osc.frequency.linearRampToValueAtTime(note.f - 20, now + note.t + note.d);

                    gain.gain.setValueAtTime(0.2, now + note.t);
                    gain.gain.linearRampToValueAtTime(0, now + note.t + note.d);
                    
                    osc.start(now + note.t);
                    osc.stop(now + note.t + note.d);
                });
            },

            schedule: function() {
                if (!this.isPlaying) return;
                while (this.nextNoteTime < audioCtx.currentTime + 0.1) {
                    this.playNote(this.sequence[this.noteIndex]);
                    this.nextNoteTime += this.sequence[this.noteIndex].d * this.tempo;
                    this.noteIndex = (this.noteIndex + 1) % this.sequence.length;
                }
                this.scheduler = setTimeout(() => this.schedule(), 25);
            },
            playNote: function(note) {
                if (note.f === 0) return;
                const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.type = 'triangle'; 
                osc.frequency.value = note.f;
                gain.gain.setValueAtTime(0.05, this.nextNoteTime); gain.gain.exponentialRampToValueAtTime(0.001, this.nextNoteTime + (note.d * this.tempo));
                osc.start(this.nextNoteTime); osc.stop(this.nextNoteTime + (note.d * this.tempo));
            }
        };

        function playSound(type) {
            // Pas de son en mode démo pour ne pas agacer
            if (gameState === 'DEMO') return;
            if (!audioCtx) return;
            const now = audioCtx.currentTime;
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);

            if (type === 'jump') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now); osc.frequency.linearRampToValueAtTime(500, now + 0.1);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(); osc.stop(now + 0.1);
            } else if (type === 'hit') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now); osc.frequency.exponentialRampToValueAtTime(20, now + 0.3);
                gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                osc.start(); osc.stop(now + 0.3);
            } else if (type === 'score') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(1000, now); 
                osc.frequency.setValueAtTime(1500, now + 0.05);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.15);
                osc.start(); osc.stop(now + 0.15);
            }
        }

        class Particle {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type;
                this.life = 1.0;
                
                if (type === 'smoke') {
                    this.vx = (Math.random() - 0.5) * 1; 
                    this.vy = (Math.random() * 1) + 1; 
                    this.size = Math.random() * 4 + 2;
                    this.color = `rgba(255, 255, 255,`;
                    this.decay = 0.03;
                } else if (type === 'score') {
                    this.vx = (Math.random() - 0.5) * 10;
                    this.vy = (Math.random() - 0.5) * 10;
                    this.size = Math.random() * 5 + 3;
                    const colors = ['#FFEB3B', '#FF5252', '#00E676', '#40C4FF'];
                    this.colorStr = colors[Math.floor(Math.random() * colors.length)];
                    this.decay = 0.02;
                } else if (type === 'explode') {
                    this.vx = (Math.random() - 0.5) * 15;
                    this.vy = (Math.random() - 0.5) * 15;
                    this.size = Math.random() * 8 + 4;
                    this.colorStr = '#FF5252';
                    this.decay = 0.05;
                }
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.life -= this.decay;
                if(this.type === 'smoke') this.size += 0.2;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                if (this.type === 'smoke') {
                    ctx.fillStyle = this.color + this.life + ')';
                    ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.fillStyle = this.colorStr;
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        function spawnParticles(x, y, count, type) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, type));
        }

        // --- Entités Graphiques ---

        const ground = {
            height: 50, x: 0,
            draw: function() {
                ctx.fillStyle = '#66BB6A'; ctx.fillRect(0, GAME_HEIGHT - this.height, GAME_WIDTH, this.height);
                ctx.fillStyle = '#43A047'; ctx.fillRect(0, GAME_HEIGHT - this.height, GAME_WIDTH, 10);
                ctx.fillStyle = '#fff';
                this.x = (this.x - gameSpeed) % 40;
                for(let i = this.x; i < GAME_WIDTH; i+=40) ctx.fillRect(i, GAME_HEIGHT - 15, 20, 5);
            }
        };

        const player = {
            x: 60, y: 150, radius: 14, velocity: 0, gravity: 0.25, jumpStrength: 4.8,
            draw: function() {
                ctx.save();
                ctx.translate(this.x, this.y);
                let rot = Math.min(Math.PI / 4, Math.max(-Math.PI / 4, (this.velocity * 0.1)));
                ctx.rotate(rot);

                ctx.fillStyle = '#C62828'; ctx.beginPath(); ctx.moveTo(-12, 2); ctx.lineTo(-22, -6); ctx.lineTo(-22, 6); ctx.fill();
                ctx.fillStyle = '#FF5252'; 
                ctx.beginPath(); ctx.ellipse(0, 5, 22, 12, 0, 0, Math.PI * 2); ctx.fill(); 
                ctx.lineWidth=2; ctx.strokeStyle='white'; ctx.stroke(); 

                ctx.fillStyle = '#FFEB3B'; ctx.beginPath(); ctx.arc(0, -4, 10, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#FF9800'; ctx.beginPath(); ctx.moveTo(8, -2); ctx.lineTo(18, 0); ctx.lineTo(8, 4); ctx.fill();
                ctx.fillStyle = '#333'; ctx.fillRect(-10, -6, 20, 3);
                ctx.fillStyle = '#4FC3F7'; ctx.beginPath(); ctx.arc(4, -4, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();

                ctx.fillStyle = '#D32F2F'; ctx.beginPath(); ctx.ellipse(-2, 8, 14, 5, 0.2, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

                ctx.fillStyle = '#EEE';
                if (frames % 4 === 0) ctx.fillRect(18, -8, 2, 24);
                else ctx.fillRect(18, 2, 2, 4); 

                ctx.restore();

                if(frames % 5 === 0 && (gameState === 'PLAYING' || gameState === 'DEMO')) spawnParticles(this.x - 20, this.y + 5, 1, 'smoke');
            },
            update: function() {
                // LOGIQUE BOT (IA) POUR LE MODE DEMO
                if (gameState === 'DEMO') {
                    // Trouver le prochain tuyau
                    let nextPipe = null;
                    for (let i = 0; i < pipes.items.length; i++) {
                        if (pipes.items[i].x + pipes.width > this.x) {
                            nextPipe = pipes.items[i];
                            break;
                        }
                    }

                    if (nextPipe) {
                        // Viser le centre du gap
                        const targetY = nextPipe.top + (pipes.gap / 2);
                        // Si on est en dessous de la cible (Y plus grand), on saute
                        if (this.y > targetY + 10) { 
                            this.jump();
                        }
                    } else {
                        // Pas de tuyau, rester au milieu (environ 200)
                        if (this.y > 200) this.jump();
                    }
                }

                this.velocity += this.gravity;
                this.y += this.velocity;
                
                // Collision sol
                if (this.y + this.radius >= GAME_HEIGHT - ground.height) { 
                    this.y = GAME_HEIGHT - ground.height - this.radius; 
                    if (gameState === 'DEMO') {
                         resetGameEnv(); gameState = 'DEMO'; // Respawn instantané en démo
                    } else {
                         gameOver(); 
                    }
                }
                
                // Plafond
                if (this.y - this.radius <= 0) { this.y = this.radius; this.velocity = 0; }
            },
            jump: function() { 
                this.velocity = -this.jumpStrength; 
                playSound('jump');
                spawnParticles(this.x, this.y + 10, 3, 'smoke');
            }
        };

        const pipes = {
            items: [], width: 55, gap: 120, dx: 2.5, spawnRate: 100,
            reset: function() { this.items = []; },
            draw: function() {
                for (let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    
                    const stripeHeight = 20;
                    const drawStripedPipe = (x, yStart, width, height, isTopPipe) => {
                        ctx.save();
                        ctx.fillStyle = '#FFF'; ctx.fillRect(x, yStart, width, height);

                        for (let sy = yStart; sy < yStart + height; sy += stripeHeight) {
                            if (Math.floor((sy - yStart) / stripeHeight) % 2 === 0) {
                                ctx.fillStyle = '#FF1744'; 
                                let h = Math.min(stripeHeight, (yStart + height) - sy);
                                ctx.fillRect(x, sy, width, h);
                            }
                        }
                        
                        ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(x + 5, yStart, 8, height);
                        ctx.lineWidth = 3; ctx.strokeStyle = '#000'; ctx.strokeRect(x, yStart, width, height);
                        ctx.fillStyle = '#263238';
                        let capY = isTopPipe ? yStart + height - 12 : yStart;
                        ctx.fillRect(x-4, capY, width+8, 12);
                        ctx.strokeRect(x-4, capY, width+8, 12);
                        ctx.restore();
                    };

                    drawStripedPipe(p.x, 0, this.width, p.top, true);
                    let bottomY = GAME_HEIGHT - ground.height - p.bottom;
                    drawStripedPipe(p.x, bottomY, this.width, p.bottom, false);
                }
            },
            update: function() {
                if (frames % this.spawnRate === 0) {
                    const minPipeLen = 50;
                    const maxPos = GAME_HEIGHT - ground.height - minPipeLen - this.gap;
                    const topHeight = Math.floor(Math.random() * (maxPos - minPipeLen + 1) + minPipeLen);
                    this.items.push({ x: GAME_WIDTH, top: topHeight, bottom: GAME_HEIGHT - ground.height - (topHeight + this.gap), passed: false });
                }
                for (let i = 0; i < this.items.length; i++) {
                    let p = this.items[i];
                    p.x -= this.dx;
                    const bh = { x: player.x - 10, y: player.y - 10, w: 20, h: 20 };
                    
                    let collision = false;
                    if (bh.x < p.x + this.width && bh.x + bh.w > p.x && bh.y < p.top) collision = true;
                    if (bh.x < p.x + this.width && bh.x + bh.w > p.x && bh.y + bh.h > GAME_HEIGHT - ground.height - p.bottom) collision = true;
                    
                    if (collision) {
                        if (gameState === 'DEMO') {
                            resetGameEnv(); gameState = 'DEMO'; // Respawn instantané
                        } else {
                            gameOver();
                        }
                    }
                    
                    if (p.x + this.width < player.x && !p.passed) { 
                        // En démo, on ne compte pas le score pour le joueur
                        if (gameState !== 'DEMO') {
                            score++; 
                            scoreEl.innerText = score; 
                            scoreEl.classList.remove('score-pop');
                            void scoreEl.offsetWidth; 
                            scoreEl.classList.add('score-pop');
                            playSound('score'); 
                            flashOpacity = 0.5;
                            spawnParticles(player.x, player.y - 50, 20, 'score');
                        }
                        p.passed = true; 
                    }
                    if (p.x + this.width <= 0) { this.items.shift(); i--; }
                }
            }
        };

        const background = {
            clouds: [],
            init: function() {
                this.clouds = [
                    {x: 50, y: 80, s: 1}, {x: 200, y: 150, s: 0.6}, {x: 350, y: 50, s: 0.8}
                ];
            },
            draw: function() {
                let grad = ctx.createLinearGradient(0, 0, 0, GAME_HEIGHT);
                grad.addColorStop(0, '#4FC3F7'); 
                grad.addColorStop(1, '#B3E5FC'); 
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,GAME_WIDTH, GAME_HEIGHT);

                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                this.clouds.forEach(c => {
                    ctx.beginPath();
                    ctx.arc(c.x, c.y, 30 * c.s, 0, Math.PI*2);
                    ctx.arc(c.x + 25*c.s, c.y - 10*c.s, 35*c.s, 0, Math.PI*2);
                    ctx.arc(c.x + 50*c.s, c.y, 30*c.s, 0, Math.PI*2);
                    ctx.fill();
                });
            },
            update: function() {
                this.clouds.forEach(c => {
                    c.x -= 0.5 * c.s;
                    if(c.x < -100) c.x = GAME_WIDTH + 100;
                });
            }
        };

        function resize() { canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT; }
        
        function resetGameEnv() {
            player.y = 150; player.velocity = 0; pipes.reset(); score = 0; frames = 0; particles = [];
            scoreEl.innerText = score; 
            gameState = 'START';
            scoreEl.style.display = 'block'; scoreEl.classList.remove('score-pop');
            shakeAmount = 0;
        }

        function startGame() {
            resetGameEnv();
            resetInactivity();
            gameState = 'PLAYING';
            startScreen.style.display = 'none';
            initAudio(); music.start(); player.jump();
        }

        function checkHighscore() {
            highScores.sort((a, b) => b.score - a.score);
            if (score > highScores[4].score) {
                newRecordSection.style.display = 'block'; playerNameInput.value = ''; playerNameInput.focus(); isHighscoreInputActive = true; 
                document.getElementById('replay-prompt').style.display = 'none';
            } else {
                newRecordSection.style.display = 'none'; 
                document.getElementById('replay-prompt').style.display = 'block';
                isHighscoreInputActive = false;
            }
        }

        btnSave.addEventListener('click', (e) => {
            e.stopPropagation(); resetInactivity();
            const name = playerNameInput.value.trim() || "ANON";
            highScores.push({ name: name.toUpperCase(), score: score });
            highScores.sort((a, b) => b.score - a.score);
            highScores = highScores.slice(0, 5);
            localStorage.setItem('cortechScores', JSON.stringify(highScores));
            newRecordSection.style.display = 'none'; 
            document.getElementById('replay-prompt').style.display = 'block';
            isHighscoreInputActive = false; updateLeaderboardDisplay();
        });
        
        btnReplay.addEventListener('click', (e) => {
            e.stopPropagation(); resetInactivity();
            gameOverScreen.style.display = 'none';
            startGame();
        });

        function gameOver() {
            if(gameState === 'GAMEOVER') return;
            gameState = 'GAMEOVER'; 
            playSound('hit'); 
            shakeAmount = 20;
            spawnParticles(player.x, player.y, 50, 'explode');

            scoreEl.style.display = 'none'; 
            gameOverScreen.style.display = 'flex'; 
            finalScoreEl.innerText = score; 
            
            // Jouer la musique Looser
            music.playLoser();
            
            checkHighscore();
        }

        function loop() {
            let tx = 0, ty = 0;
            if (shakeAmount > 0) {
                tx = (Math.random() - 0.5) * shakeAmount;
                ty = (Math.random() - 0.5) * shakeAmount;
                shakeAmount *= 0.9; 
                if(shakeAmount < 0.5) shakeAmount = 0;
            }

            ctx.save();
            ctx.translate(tx, ty); 

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            background.draw();
            if (gameState === 'PLAYING' || gameState === 'DEMO') background.update();

            pipes.draw();
            if (gameState === 'PLAYING' || gameState === 'DEMO') pipes.update();
            
            ground.draw();
            
            for(let i=particles.length-1; i>=0; i--) {
                particles[i].update();
                particles[i].draw(ctx);
                if(particles[i].life <= 0) particles.splice(i, 1);
            }

            player.draw();
            if (gameState === 'PLAYING' || gameState === 'DEMO') { player.update(); frames++; }
            else if (gameState === 'START') { player.y = 150 + Math.sin(Date.now() / 300) * 8; }
            
            ctx.restore(); 

            if (flashOpacity > 0) {
                ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity})`;
                ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
                flashOpacity -= 0.05;
            }

            requestAnimationFrame(loop);
        }

        function inputAction(e) {
            // Toujours réinitialiser le timer d'inactivité
            resetInactivity();
            
            if (isHighscoreInputActive) return;
            // Ignore boutons
            if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') return;
            
            if(e.type !== 'click') e.preventDefault();
            
            if (gameState === 'START') startGame();
            else if (gameState === 'PLAYING') player.jump();
        }

        // Ecouter toutes les interactions pour le timer
        window.addEventListener('keydown', (e) => { 
            resetInactivity();
            if (!isHighscoreInputActive && e.code === 'Space') inputAction(e); 
        });
        window.addEventListener('mousedown', inputAction);
        window.addEventListener('touchstart', inputAction, {passive: false});
        window.addEventListener('mousemove', resetInactivity); // Pour détecter le mouvement sans clic

        background.init();
        updateLeaderboardDisplay(); 
        resize(); 
        loop();
    </script>
</body>
</html>
